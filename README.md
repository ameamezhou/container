"# container" 

### 1、 docker 容器入门
### 2、 docker 容器原理
### 3、 docker 容器化服务常见问题
### 4、 docker 容器编排和部署
### 5、 总结
############################################################
正文
##### 1.1 虚拟化 Virtualization

虚拟化是一种资源管理技术，将计算机的各种资源(CPU,MEM,DISK,NET device)予以抽象，转换后呈现出来并提供可分割
、组合为一个或多个计算机的配置环境，虚拟化技术打破了计算机内部实体结构不可分割的障碍，使用户能够以比原本更好的配置方式来
应用这些计算机硬件资源。

关键字: 抽象、分割 资源   将一台计算机分割为多台机器使用

##### 1.2 什么是容器？ 为什么要用容器

先引入一下传统的虚拟化和操作系统虚拟化的区别   操作系统虚拟化也就是我们所说的容器

发展进程：
    
    1.2.1 全虚拟化 (见文字图1)
            1) 不需要定制的Guest OS
            2) 虚拟机的硬件由软件进行抽象提供
            3) 性能较差
            4) 安全性较好
            对于全虚拟化的Guest OS 来说，它的硬件都是虚构的，它执行的指令都要有 Hypervisor 翻译，运行效率比较低

    
    1.2.2 半虚拟化 (见文字图2)
            1) 需要定制的Guest OS
            2) 虚拟机可以直接用CPU等硬件
            3) 性能接近于物理机
            4) 安全性好
            半虚拟化和全虚拟化最大的差别就是半虚拟化能直接使用硬件设备，但是问题是 Guest OS 需要定制，甚至运行的程序也是特殊版本
            同事也没有解决你虚拟机里需要额外运行一个 Guest OS 所造成的 CPU MEM 浪费问题

    1.2.3 操作系统虚拟化 (见文字图3)
            也就是我们所说的容器
            1) 不需要 Guest OS, 和宿主机共享内核
            2) 直接使用 CPU 等硬件
            3) 性能几乎和物理机没有差别
            4) 安全性较差
            容器的实现和传统虚拟化是相当不同的一个方式, 它不需要 Hypervisor，容器的进程实际上就是运行在宿主机的OS上的，容器通过
            操作系统提供的一些列隔离机制限制某几个或者某个进程所获得的资源信息，形成一个看不见的墙，把这组进程罩在一个罩子里面

##### 1.3 容器发展的历史

> 1979年 chroot 命令的提出是隔离的雏形, 通过切换root目录达到一定隔离进程的目的
> 
> 2004年 早期容器
> 
> 2007年 Google 向 Linux 提交了 CGroup, 形成了 Linux 容器技术上的一个基石
> 
> 2008年 Linux 上有了 lxc 容器
> 
> 2013年 docker 有了镜像的容器, 有了镜像之后容器技术就能像传统虚拟化一样进行迁移分发然后再运行
> 
> 2018年 又出现了一些安全容器 比如 kata gVisor 之类的

##### 1.4 容器的用途

早期用途：

1. 轻量化沙箱 - 利用隔离能力可以进行一些测试以及服务检测等相关应用
2. 快速部署 - 利用docker镜像, 有了镜像之后就可以像传统虚拟化一样进行迁移分发然后再运行
3. 轻量级的虚拟化 - 利用通过容器的快速部署能力，把容器当虚拟机使用


    和传统的虚拟机比，容器的优点:

    1. 秒级的自动启动
    2. 更轻量的镜像，降低传输耗时
    3. 直接在宿主机上运行，性能损耗小
    
    缺点:
    1. 隔离相比于传统的VM较差

##### 2.1 操作docker

流程简述: 
`docker pull centos -> docker run -ti centos bash -> cker rm -f container_id`

文字描述: 拉取镜像 -> 启动容器 -> 销毁容器

==================================================================

docker pull centos

docker images // 输出所有拉下来的镜像

docker images 里关注 TAG 和 IMAGE ID   一个是版本号  一个是可以通过镜像ID启动一个容器

docker run -ti centos bash   // 这里用 centos 镜像名或者IMAGE ID 都可以

简单介绍一下这个命令

docker run 是启动

-t 是让docker加载一个伪终端

-i 是让伪终端交互打开

输入命令后会进入容器的伪终端  按住 ctrl + p + q 就可以退出

=======================================================================

docker 命令的一些补充

1. docker ps 可以看一下所有运行的容器
2. docker kill container_id 结束这个容器的运行
3. docker kill 结束了容器的运行 但是没有销毁，docker ps -a 可以看到所有的容器
4. docker rm -f container_id 就可以销毁容器

##### 2.2 dockerfile

这里是docker最关键的镜像，我们写docker的内容时 要知道怎样去写一个镜像
打镜像我们也有两种方式
1. dockerfile, 命名一个 dockerfile 文件，将内容写在里面 然后用docker build -t myimg:1.0.1 $DIR  这里-t是指定它镜像名和tag
2. 我们可以启动一个容器，在里面安装各种东西，之后用 docker commit 导出也可以打一个镜像

业内推荐的方式是写dockerfile

===========================================

写个docker file的 例子把

dockerfile  见文件

full.cpp 见文件

g++ 编译 full full.cpp

在Linux服务器中让他们属于同一目录下

docker build -t myimg:0.1.0 .

记得一定要加 . 表示当前目录    这里要指定编译目录

docker images  看看我们编译好的镜像

docker run -ti image_id bash

我们进入启动的容器后  可以去  /usr/local 下看我们搞的 full 二进制和 test.txt 文件

===========================================